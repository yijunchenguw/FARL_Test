% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FARLR_EMM.R
\name{farlr_emm}
\alias{farlr_emm}
\title{FARLR EM-M Algorithm for Latent Regression with Regularization}
\usage{
farlr_emm(
  n,
  resp,
  parTab,
  K_hat,
  p,
  lambda_all,
  delta.criteria = 0.001,
  iter.max = 500,
  n_sam = 50,
  window.size = 50,
  theta_est_irt.mean,
  theta_est_irt.se,
  resp_rep,
  Z.em,
  Uupdate = NA,
  hatU = NA,
  Fan = NA,
  main,
  verbose = TRUE
)
}
\arguments{
\item{n}{Integer. Sample size (number of persons).}

\item{resp}{Matrix. Observed item responses of dimension \code{n x J}.}

\item{parTab}{Data frame. Item parameter table containing at least
\code{slope}, \code{difficulty}, and \code{guessin}.}

\item{K_hat}{Integer. Number of latent factors/components included in \code{Z.em}.}

\item{p}{Integer. Number of covariates/predictors included in \code{Z.em}.}

\item{lambda_all}{Numeric vector. Candidate regularization parameters passed to
\code{glmnet}.}

\item{delta.criteria}{Numeric. Convergence tolerance for parameter updates.
Default is \code{1e-3}.}

\item{iter.max}{Integer. Maximum number of EM iterations for each \code{lambda}.
Default is \code{500}.}

\item{n_sam}{Integer. Number of Monte Carlo samples per subject used in the
E-step. Default is \code{50}.}

\item{window.size}{Integer. Sliding window size used to average coefficient
updates across iterations. Default is \code{50}.}

\item{theta_est_irt.mean}{Numeric vector of length \code{n}. IRT-based posterior
mean estimates of latent trait \eqn{\theta}.}

\item{theta_est_irt.se}{Numeric vector of length \code{n}. IRT-based posterior
standard error estimates of \eqn{\theta}.}

\item{resp_rep}{Matrix. Replicated/expanded responses used for Monte Carlo
computations in the E-step (see \code{q_num_NA}).}

\item{Z.em}{Matrix. Design matrix used in the regression step, typically of
dimension \code{n x (K_hat + p)}.}

\item{main}{Integer index (or indices). Predictor(s) to be treated as
unpenalized via \code{penalty.factor} (set to 0). All other predictors are
penalized unless already unpenalized in the first \code{K_hat} columns.}

\item{verbose}{Logical. If \code{TRUE}, prints progress messages and a progress bar.
Default is \code{TRUE}.}
}
\value{
A list with the following elements:
\describe{
  \item{\code{coefficients}}{Estimated regression coefficients at the selected
  \code{lambda} (length \code{K_hat + p}).}
  \item{\code{sigma}}{Estimated residual standard deviation.}
  \item{\code{LogLik}}{BIC-like objective value corresponding to the selected \code{lambda}
  (named \code{LogLik} for compatibility).}
  \item{\code{minBIC}}{Index of \code{lambda_all} achieving the minimum BIC criterion.}
  \item{\code{Convergence}}{A character flag indicating convergence status.}
}
}
\description{
Fits a FARLR-style latent regression model using an EM-M algorithm.
In the E-step, latent traits are sampled from a normal approximation based on
IRT estimates (\code{theta_est_irt.mean}, \code{theta_est_irt.se}). In the M-step,
regression coefficients are updated using weighted \code{glmnet} (LASSO) with a
debiasing refit via weighted least squares. A sliding window averaging scheme
is used to stabilize coefficient updates across iterations. The tuning
parameter \code{lambda} is selected by minimizing a BIC-like criterion over
\code{lambda_all}.
}
\details{
For each \code{lambda} in \code{lambda_all}, the algorithm iterates until
\code{delta} falls below \code{delta.criteria} or \code{iter.max} is reached.
The maximum change in coefficient and residual scale estimates is monitored:
\eqn{\delta = \max(|\sigma^{(t)}-\sigma^{(t-1)}|, \max_j |\beta_j^{(t)}-\beta_j^{(t-1)}|)}.

This function relies on helper functions (not shown here), including
\code{q_num_NA()} and \code{add_to_window()}.
}
\examples{
\dontrun{
fit <- farlr_emm(
  n = nrow(resp),
  resp = resp,
  parTab = parTab,
  K_hat = K_hat,
  p = p,
  lambda_all = seq(0.001, 0.1, length.out = 10),
  theta_est_irt.mean = theta_mean,
  theta_est_irt.se = theta_se,
  resp_rep = resp_rep,
  Z.em = Z.em,
  main = 1,
  verbose = TRUE
)
}

}
\seealso{
\code{\link[glmnet]{glmnet}}, \code{\link[mirt]{simdata}}
}
